/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/tinybind/dist/tinybind.js":
/*!************************************************!*\
  !*** ./node_modules/tinybind/dist/tinybind.js ***!
  \************************************************/
/***/ (function(module) {

eval("(function (global, factory) {\n   true ? module.exports = factory() :\n  0;\n}(this, function () { 'use strict';\n\n  var OPTIONS = ['prefix', 'templateDelimiters', 'rootInterface', 'preloadData', 'handler'];\n  var EXTENSIONS = ['binders', 'formatters', 'adapters'];\n\n  var PRIMITIVE = 0;\n  var KEYPATH = 1;\n  var TEXT = 0;\n  var BINDING = 1;\n  var QUOTED_STR = /^'.*'$|^\".*\"$/; // Parser and tokenizer for getting the type and value from a string.\n\n  function parseType(string) {\n    var type = PRIMITIVE;\n    var value = string;\n\n    if (QUOTED_STR.test(string)) {\n      value = string.slice(1, -1);\n    } else if (string === 'true') {\n      value = true;\n    } else if (string === 'false') {\n      value = false;\n    } else if (string === 'null') {\n      value = null;\n    } else if (string === 'undefined') {\n      value = undefined;\n    } else if (!isNaN(string)) {\n      value = Number(string);\n    } else {\n      type = KEYPATH;\n    }\n\n    return {\n      type: type,\n      value: value\n    };\n  } // Template parser and tokenizer for mustache-style text content bindings.\n  // Parses the template and returns a set of tokens, separating static portions\n  // of text from binding declarations.\n\n  function parseTemplate(template, delimiters) {\n    var tokens;\n    var length = template.length;\n    var index = 0;\n    var lastIndex = 0;\n    var open = delimiters[0],\n        close = delimiters[1];\n\n    while (lastIndex < length) {\n      index = template.indexOf(open, lastIndex);\n\n      if (index < 0) {\n        if (tokens) {\n          tokens.push({\n            type: TEXT,\n            value: template.slice(lastIndex)\n          });\n        }\n\n        break;\n      } else {\n        tokens || (tokens = []);\n\n        if (index > 0 && lastIndex < index) {\n          tokens.push({\n            type: TEXT,\n            value: template.slice(lastIndex, index)\n          });\n        }\n\n        lastIndex = index + open.length;\n        index = template.indexOf(close, lastIndex);\n\n        if (index < 0) {\n          var substring = template.slice(lastIndex - close.length);\n          var lastToken = tokens[tokens.length - 1];\n\n          if (lastToken && lastToken.type === TEXT) {\n            lastToken.value += substring;\n          } else {\n            tokens.push({\n              type: TEXT,\n              value: substring\n            });\n          }\n\n          break;\n        }\n\n        var value = template.slice(lastIndex, index).trim();\n        tokens.push({\n          type: BINDING,\n          value: value\n        });\n        lastIndex = index + close.length;\n      }\n    }\n\n    return tokens;\n  }\n\n  var tinybind = {\n    // Global binders.\n    binders: {},\n    // Global formatters.\n    formatters: {},\n    // Global sightglass adapters.\n    adapters: {},\n    // Default attribute prefix.\n    _prefix: 'rv',\n    _fullPrefix: 'rv-',\n\n    get prefix() {\n      return this._prefix;\n    },\n\n    set prefix(value) {\n      this._prefix = value;\n      this._fullPrefix = value + '-';\n    },\n\n    parseTemplate: parseTemplate,\n    parseType: parseType,\n    // Default template delimiters.\n    templateDelimiters: ['{', '}'],\n    // Default sightglass root interface.\n    rootInterface: '.',\n    // Preload data by default.\n    preloadData: true,\n    // Default event handler.\n    handler: function handler(context, ev, binding) {\n      this.call(context, ev, binding.view.models);\n    },\n    // Sets the attribute on the element. If no binder above is matched it will fall\n    // back to using this binder.\n    fallbackBinder: function fallbackBinder(el, value) {\n      if (value != null) {\n        el.setAttribute(this.type, value);\n      } else {\n        el.removeAttribute(this.type);\n      }\n    },\n    // Merges an object literal into the corresponding global options.\n    configure: function configure(options) {\n      var _this = this;\n\n      if (!options) {\n        return;\n      }\n\n      Object.keys(options).forEach(function (option) {\n        var value = options[option];\n\n        if (EXTENSIONS.indexOf(option) > -1) {\n          Object.keys(value).forEach(function (key) {\n            _this[option][key] = value[key];\n          });\n        } else {\n          _this[option] = value;\n        }\n      });\n    }\n  };\n\n  // Check if a value is an object than can be observed.\n  function isObject(obj) {\n    return typeof obj === 'object' && obj !== null;\n  } // Error thrower.\n\n\n  function error(message) {\n    throw new Error(\"[Observer] \" + message);\n  }\n\n  var adapters;\n  var interfaces;\n  var rootInterface; // Constructs a new keypath observer and kicks things off.\n\n  var Observer =\n  /*#__PURE__*/\n  function () {\n    Observer.updateOptions = function updateOptions(options) {\n      adapters = options.adapters;\n      interfaces = Object.keys(adapters);\n      rootInterface = options.rootInterface;\n    } // Tokenizes the provided keypath string into interface + path tokens for the\n    // observer to work with.\n    ;\n\n    Observer.tokenize = function tokenize(keypath, root) {\n      var tokens = [];\n      var current = {\n        i: root,\n        path: ''\n      };\n      var index;\n      var chr;\n\n      for (index = 0; index < keypath.length; index++) {\n        chr = keypath.charAt(index);\n\n        if (!!~interfaces.indexOf(chr)) {\n          tokens.push(current);\n          current = {\n            i: chr,\n            path: ''\n          };\n        } else {\n          current.path += chr;\n        }\n      }\n\n      tokens.push(current);\n      return tokens;\n    };\n\n    function Observer(obj, keypath, callback) {\n      this.keypath = keypath;\n      this.callback = callback;\n      this.objectPath = [];\n      this.parse();\n      this.obj = this.getRootObject(obj);\n\n      if (isObject(this.target = this.realize())) {\n        this.set(true, this.key, this.target, this.callback);\n      }\n    } // Parses the keypath using the interfaces defined on the view. Sets variables\n    // for the tokenized keypath as well as the end key.\n\n\n    var _proto = Observer.prototype;\n\n    _proto.parse = function parse() {\n      var path;\n      var root;\n\n      if (!interfaces.length) {\n        error('Must define at least one adapter interface.');\n      }\n\n      if (!!~interfaces.indexOf(this.keypath[0])) {\n        root = this.keypath[0];\n        path = this.keypath.substr(1);\n      } else {\n        root = rootInterface;\n        path = this.keypath;\n      }\n\n      this.tokens = Observer.tokenize(path, root);\n      this.key = this.tokens.pop();\n    } // Realizes the full keypath, attaching observers for every key and correcting\n    // old observers to any changed objects in the keypath.\n    ;\n\n    _proto.realize = function realize() {\n      var current = this.obj;\n      var unreached = -1;\n      var prev;\n      var token;\n\n      for (var index = 0; index < this.tokens.length; index++) {\n        token = this.tokens[index];\n\n        if (isObject(current)) {\n          if (typeof this.objectPath[index] !== 'undefined') {\n            if (current !== (prev = this.objectPath[index])) {\n              this.set(false, token, prev, this);\n              this.set(true, token, current, this);\n              this.objectPath[index] = current;\n            }\n          } else {\n            this.set(true, token, current, this);\n            this.objectPath[index] = current;\n          }\n\n          current = this.get(token, current);\n        } else {\n          if (unreached === -1) {\n            unreached = index;\n          }\n\n          if (prev = this.objectPath[index]) {\n            this.set(false, token, prev, this);\n          }\n        }\n      }\n\n      if (unreached !== -1) {\n        this.objectPath.splice(unreached);\n      }\n\n      return current;\n    } // Updates the keypath. This is called when any intermediary key is changed.\n    ;\n\n    _proto.sync = function sync() {\n      var next;\n      var oldValue;\n      var newValue;\n\n      if ((next = this.realize()) !== this.target) {\n        if (isObject(this.target)) {\n          this.set(false, this.key, this.target, this.callback);\n        }\n\n        if (isObject(next)) {\n          this.set(true, this.key, next, this.callback);\n        }\n\n        oldValue = this.value();\n        this.target = next;\n        newValue = this.value();\n        if (newValue !== oldValue || newValue instanceof Function) this.callback.sync();\n      } else if (next instanceof Array) {\n        this.callback.sync();\n      }\n    } // Reads the current end value of the observed keypath. Returns undefined if\n    // the full keypath is unreachable.\n    ;\n\n    _proto.value = function value() {\n      if (isObject(this.target)) {\n        return this.get(this.key, this.target);\n      }\n    } // Sets the current end value of the observed keypath. Calling setValue when\n    // the full keypath is unreachable is a no-op.\n    ;\n\n    _proto.setValue = function setValue(value) {\n      if (isObject(this.target)) {\n        adapters[this.key.i].set(this.target, this.key.path, value);\n      }\n    } // Gets the provided key on an object.\n    ;\n\n    _proto.get = function get(key, obj) {\n      return adapters[key.i].get(obj, key.path);\n    } // Observes or unobserves a callback on the object using the provided key.\n    ;\n\n    _proto.set = function set(active, key, obj, callback) {\n      var action = active ? 'observe' : 'unobserve';\n      adapters[key.i][action](obj, key.path, callback);\n    } // Unobserves the entire keypath.\n    ;\n\n    _proto.unobserve = function unobserve() {\n      var obj;\n      var token;\n\n      for (var index = 0; index < this.tokens.length; index++) {\n        token = this.tokens[index];\n\n        if (obj = this.objectPath[index]) {\n          this.set(false, token, obj, this);\n        }\n      }\n\n      if (isObject(this.target)) {\n        this.set(false, this.key, this.target, this.callback);\n      }\n    } // traverse the scope chain to find the scope which has the root property\n    // if the property is not found in chain, returns the root scope\n    ;\n\n    _proto.getRootObject = function getRootObject(obj) {\n      var rootProp;\n      var current;\n\n      if (!obj.$parent) {\n        return obj;\n      }\n\n      if (this.tokens.length) {\n        rootProp = this.tokens[0].path;\n      } else {\n        rootProp = this.key.path;\n      }\n\n      current = obj;\n\n      while (current.$parent && current[rootProp] === undefined) {\n        current = current.$parent;\n      }\n\n      return current;\n    };\n\n    return Observer;\n  }();\n\n  function getInputValue(el) {\n    if (el.type === 'checkbox') {\n      return el.checked;\n    } else if (el.type === 'select-multiple') {\n      var results = [];\n      var option;\n\n      for (var i = 0; i < el.options.length; i++) {\n        option = el.options[i];\n\n        if (option.selected) {\n          results.push(option.value);\n        }\n      }\n\n      return results;\n    } else {\n      return el.value;\n    }\n  }\n\n  var FORMATTER_ARGS = /[^\\s']+|'([^']|'[^\\s])*'|\"([^\"]|\"[^\\s])*\"/g;\n  var FORMATTER_SPLIT = /\\s+/; // A single binding between a model attribute and a DOM element.\n\n  var Binding =\n  /*#__PURE__*/\n  function () {\n    // All information about the binding is passed into the constructor; the\n    // containing view, the DOM node, the type of binding, the model object and the\n    // keypath at which to listen for changes.\n    function Binding(view, el, type, keypath, binder, arg, formatters) {\n      this.view = view;\n      this.el = el;\n      this.type = type;\n      this.keypath = keypath;\n      this.binder = binder;\n      this.arg = arg;\n      this.formatters = formatters;\n      this.formatterObservers = {};\n      this.model = undefined;\n    } // Observes the object keypath\n\n\n    var _proto = Binding.prototype;\n\n    _proto.observe = function observe(obj, keypath) {\n      return new Observer(obj, keypath, this);\n    };\n\n    _proto.parseTarget = function parseTarget() {\n      if (this.keypath) {\n        var token = parseType(this.keypath);\n\n        if (token.type === 0) {\n          this.value = token.value;\n        } else {\n          this.observer = this.observe(this.view.models, this.keypath);\n          this.model = this.observer.target;\n        }\n      } else {\n        this.value = undefined;\n      }\n    };\n\n    _proto.parseFormatterArguments = function parseFormatterArguments(args, formatterIndex) {\n      var _this = this;\n\n      return args.map(parseType).map(function (_ref, ai) {\n        var type = _ref.type,\n            value = _ref.value;\n\n        if (type === 0) {\n          return value;\n        } else {\n          if (!_this.formatterObservers[formatterIndex]) {\n            _this.formatterObservers[formatterIndex] = {};\n          }\n\n          var observer = _this.formatterObservers[formatterIndex][ai];\n\n          if (!observer) {\n            observer = _this.observe(_this.view.models, value);\n            _this.formatterObservers[formatterIndex][ai] = observer;\n          }\n\n          return observer.value();\n        }\n      });\n    } // Applies all the current formatters to the supplied value and returns the\n    // formatted value.\n    ;\n\n    _proto.formattedValue = function formattedValue(value) {\n      var _this2 = this;\n\n      return this.formatters.reduce(function (result, declaration, index) {\n        var args = declaration.match(FORMATTER_ARGS);\n        var id = args.shift();\n        var formatter = _this2.view.options.formatters[id];\n\n        var processedArgs = _this2.parseFormatterArguments(args, index);\n\n        if (formatter && formatter.read instanceof Function) {\n          result = formatter.read.apply(formatter, [result].concat(processedArgs));\n        } else if (formatter instanceof Function) {\n          result = formatter.apply(void 0, [result].concat(processedArgs));\n        }\n\n        return result;\n      }, value);\n    } // Returns an event handler for the binding around the supplied function.\n    ;\n\n    _proto.eventHandler = function eventHandler(fn) {\n      var binding = this;\n      var handler = binding.view.options.handler;\n      return function (ev) {\n        handler.call(fn, this, ev, binding);\n      };\n    } // Sets the value for the binding. This Basically just runs the binding routine\n    // with the supplied value formatted.\n    ;\n\n    _proto.set = function set(value) {\n      if (value instanceof Function && !this.binder.function) {\n        value = this.formattedValue(value.call(this.model));\n      } else {\n        value = this.formattedValue(value);\n      }\n\n      var routineFn = this.binder.routine || this.binder;\n\n      if (routineFn instanceof Function) {\n        routineFn.call(this, this.el, value);\n      }\n    } // Syncs up the view binding with the model.\n    ;\n\n    _proto.sync = function sync() {\n      if (this.observer) {\n        this.model = this.observer.target;\n        this.set(this.observer.value());\n      } else {\n        this.set(this.value);\n      }\n    } // Publishes the value currently set on the input element back to the model.\n    ;\n\n    _proto.publish = function publish() {\n      var _this3 = this;\n\n      if (this.observer) {\n        var value = this.formatters.reduceRight(function (result, declaration, index) {\n          var args = declaration.split(FORMATTER_SPLIT);\n          var id = args.shift();\n          var formatter = _this3.view.options.formatters[id];\n\n          var processedArgs = _this3.parseFormatterArguments(args, index);\n\n          if (formatter && formatter.publish) {\n            result = formatter.publish.apply(formatter, [result].concat(processedArgs));\n          }\n\n          return result;\n        }, this.getValue(this.el));\n        this.observer.setValue(value);\n      }\n    } // Subscribes to the model for changes at the specified keypath. Bi-directional\n    // routines will also listen for changes on the element to propagate them back\n    // to the model.\n    ;\n\n    _proto.bind = function bind() {\n      this.parseTarget();\n\n      if (this.binder.hasOwnProperty('bind')) {\n        this.binder.bind.call(this, this.el);\n      }\n\n      if (this.view.options.preloadData) {\n        this.sync();\n      }\n    } // Unsubscribes from the model and the element.\n    ;\n\n    _proto.unbind = function unbind() {\n      var _this4 = this;\n\n      if (this.binder.unbind) {\n        this.binder.unbind.call(this, this.el);\n      }\n\n      if (this.observer) {\n        this.observer.unobserve();\n      }\n\n      Object.keys(this.formatterObservers).forEach(function (fi) {\n        var args = _this4.formatterObservers[fi];\n        Object.keys(args).forEach(function (ai) {\n          args[ai].unobserve();\n        });\n      });\n      this.formatterObservers = {};\n    } // Updates the binding's model from what is currently set on the view. Unbinds\n    // the old model first and then re-binds with the new model.\n    ;\n\n    _proto.update = function update(models) {\n      if (models === void 0) {\n        models = {};\n      }\n\n      if (this.observer) {\n        this.model = this.observer.target;\n      }\n\n      if (this.binder.update) {\n        this.binder.update.call(this, models);\n      }\n    } // Returns elements value\n    ;\n\n    _proto.getValue = function getValue(el) {\n      if (this.binder && this.binder.getValue) {\n        return this.binder.getValue.call(this, el);\n      } else {\n        return getInputValue(el);\n      }\n    };\n\n    return Binding;\n  }();\n\n  var textBinder = {\n    routine: function routine(node, value) {\n      node.data = value != null ? value : '';\n    }\n  };\n  var DECLARATION_SPLIT = /((?:'[^']*')*(?:(?:[^\\|']*(?:'[^']*')+[^\\|']*)+|[^\\|]+))|^$/g;\n\n  var parseNode = function parseNode(view, node) {\n    var block = false;\n\n    if (node.nodeType === 3) {\n      var tokens = parseTemplate(node.data, tinybind.templateDelimiters);\n\n      if (tokens) {\n        for (var i = 0; i < tokens.length; i++) {\n          var token = tokens[i];\n          var text = document.createTextNode(token.value);\n          node.parentNode.insertBefore(text, node);\n\n          if (token.type === 1) {\n            view.buildBinding(text, null, token.value, textBinder, null);\n          }\n        }\n\n        node.parentNode.removeChild(node);\n      }\n\n      block = true;\n    } else if (node.nodeType === 1) {\n      block = view.traverse(node);\n    }\n\n    if (!block) {\n      for (var _i = 0; _i < node.childNodes.length; _i++) {\n        parseNode(view, node.childNodes[_i]);\n      }\n    }\n  };\n\n  var bindingComparator = function bindingComparator(a, b) {\n    var aPriority = a.binder ? a.binder.priority || 0 : 0;\n    var bPriority = b.binder ? b.binder.priority || 0 : 0;\n    return bPriority - aPriority;\n  };\n\n  var trimStr = function trimStr(str) {\n    return str.trim();\n  }; // A collection of bindings built from a set of parent nodes.\n\n\n  var View =\n  /*#__PURE__*/\n  function () {\n    // The DOM elements and the model objects for binding are passed into the\n    // constructor along with any local options that should be used throughout the\n    // context of the view and it's bindings.\n    function View(els, models, options) {\n      if (els.jquery || els instanceof Array) {\n        this.els = els;\n      } else {\n        this.els = [els];\n      }\n\n      this.models = models;\n      this.options = options;\n      this.build();\n    }\n\n    var _proto = View.prototype;\n\n    _proto.buildBinding = function buildBinding(node, type, declaration, binder, arg) {\n      var pipes = declaration.match(DECLARATION_SPLIT).map(trimStr);\n      var keypath = pipes.shift();\n      this.bindings.push(new Binding(this, node, type, keypath, binder, arg, pipes));\n    } // Parses the DOM tree and builds `Binding` instances for every matched\n    // binding declaration.\n    ;\n\n    _proto.build = function build() {\n      this.bindings = [];\n      var elements = this.els,\n          i,\n          len;\n\n      for (i = 0, len = elements.length; i < len; i++) {\n        parseNode(this, elements[i]);\n      }\n\n      this.bindings.sort(bindingComparator);\n    };\n\n    _proto.traverse = function traverse(node) {\n      var bindingPrefix = tinybind._fullPrefix;\n      var block = node.nodeName === 'SCRIPT' || node.nodeName === 'STYLE';\n      var attributes = node.attributes;\n      var bindInfos = [];\n      var starBinders = this.options.starBinders;\n      var type, binder, identifier, arg;\n\n      for (var i = 0, len = attributes.length; i < len; i++) {\n        var attribute = attributes[i];\n\n        if (attribute.name.indexOf(bindingPrefix) === 0) {\n          type = attribute.name.slice(bindingPrefix.length);\n          binder = this.options.binders[type];\n          arg = undefined;\n\n          if (!binder) {\n            for (var k = 0; k < starBinders.length; k++) {\n              identifier = starBinders[k];\n\n              if (type.slice(0, identifier.length - 1) === identifier.slice(0, -1)) {\n                binder = this.options.binders[identifier];\n                arg = type.slice(identifier.length - 1);\n                break;\n              }\n            }\n          }\n\n          if (!binder) {\n            binder = tinybind.fallbackBinder;\n          }\n\n          if (binder.block) {\n            this.buildBinding(node, type, attribute.value, binder, arg);\n            node.removeAttribute(attribute.name);\n            return true;\n          }\n\n          bindInfos.push({\n            attr: attribute,\n            binder: binder,\n            type: type,\n            arg: arg\n          });\n        }\n      }\n\n      for (var _i2 = 0; _i2 < bindInfos.length; _i2++) {\n        var bindInfo = bindInfos[_i2];\n        this.buildBinding(node, bindInfo.type, bindInfo.attr.value, bindInfo.binder, bindInfo.arg);\n        node.removeAttribute(bindInfo.attr.name);\n      }\n\n      return block;\n    } // Binds all of the current bindings for this view.\n    ;\n\n    _proto.bind = function bind() {\n      this.bindings.forEach(function (binding) {\n        binding.bind();\n      });\n    } // Unbinds all of the current bindings for this view.\n    ;\n\n    _proto.unbind = function unbind() {\n      this.bindings.forEach(function (binding) {\n        binding.unbind();\n      });\n    } // Syncs up the view with the model by running the routines on all bindings.\n    ;\n\n    _proto.sync = function sync() {\n      this.bindings.forEach(function (binding) {\n        binding.sync();\n      });\n    } // Publishes the input values from the view back to the model (reverse sync).\n    ;\n\n    _proto.publish = function publish() {\n      this.bindings.forEach(function (binding) {\n        if (binding.binder && binding.binder.publishes) {\n          binding.publish();\n        }\n      });\n    } // Updates the view's models along with any affected bindings.\n    ;\n\n    _proto.update = function update(models) {\n      var _this = this;\n\n      if (models === void 0) {\n        models = {};\n      }\n\n      Object.keys(models).forEach(function (key) {\n        _this.models[key] = models[key];\n      });\n      this.bindings.forEach(function (binding) {\n        if (binding.update) {\n          binding.update(models);\n        }\n      });\n    };\n\n    return View;\n  }();\n\n  // The default `.` adapter that comes with tinybind.js. Allows subscribing to\n  // properties on plain objects, implemented in ES5 natives using\n  // `Object.defineProperty`.\n  var ARRAY_METHODS = ['push', 'pop', 'shift', 'unshift', 'sort', 'reverse', 'splice'];\n  var adapter = {\n    counter: 0,\n    weakmap: {},\n    weakReference: function weakReference(obj) {\n      if (!obj.hasOwnProperty('__rv')) {\n        var id = this.counter++;\n        Object.defineProperty(obj, '__rv', {\n          value: id\n        });\n      }\n\n      if (!this.weakmap[obj.__rv]) {\n        this.weakmap[obj.__rv] = {\n          callbacks: {}\n        };\n      }\n\n      return this.weakmap[obj.__rv];\n    },\n    cleanupWeakReference: function cleanupWeakReference(data, refId) {\n      if (!Object.keys(data.callbacks).length) {\n        if (!(data.pointers && Object.keys(data.pointers).length)) {\n          delete this.weakmap[refId];\n        }\n      }\n    },\n    stubFunction: function stubFunction(obj, fn) {\n      var original = obj[fn];\n      var data = this.weakReference(obj);\n      var weakmap = this.weakmap;\n\n      obj[fn] = function () {\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        var response = original.apply(obj, args);\n        Object.keys(data.pointers).forEach(function (refId) {\n          var k = data.pointers[refId];\n\n          if (weakmap[refId]) {\n            if (weakmap[refId].callbacks[k] instanceof Array) {\n              weakmap[refId].callbacks[k].forEach(function (callback) {\n                callback.sync();\n              });\n            }\n          }\n        });\n        return response;\n      };\n    },\n    observeArray: function observeArray(value, refId, keypath) {\n      var _this = this;\n\n      if (value instanceof Array) {\n        var data = this.weakReference(value);\n\n        if (!data.pointers) {\n          data.pointers = {};\n          ARRAY_METHODS.forEach(function (fn) {\n            _this.stubFunction(value, fn);\n          });\n        }\n\n        if (!data.pointers[refId]) {\n          data.pointers[refId] = [];\n        }\n\n        if (data.pointers[refId].indexOf(keypath) === -1) {\n          data.pointers[refId].push(keypath);\n        }\n      }\n    },\n    unobserveArray: function unobserveArray(value, refId, keypath) {\n      if (value instanceof Array && value.__rv != null) {\n        var data = this.weakmap[value.__rv];\n\n        if (data) {\n          var pointers = data.pointers[refId];\n\n          if (pointers) {\n            var idx = pointers.indexOf(keypath);\n\n            if (idx > -1) {\n              pointers.splice(idx, 1);\n            }\n\n            if (!pointers.length) {\n              delete data.pointers[refId];\n            }\n\n            this.cleanupWeakReference(data, value.__rv);\n          }\n        }\n      }\n    },\n    observe: function observe(obj, keypath, callback) {\n      var _this2 = this;\n\n      var value;\n      var callbacks = this.weakReference(obj).callbacks;\n\n      if (!callbacks[keypath]) {\n        callbacks[keypath] = [];\n        var desc = Object.getOwnPropertyDescriptor(obj, keypath);\n\n        if (!desc || !(desc.get || desc.set || !desc.configurable)) {\n          value = obj[keypath];\n          Object.defineProperty(obj, keypath, {\n            enumerable: true,\n            get: function get() {\n              return value;\n            },\n            set: function set(newValue) {\n              if (newValue !== value) {\n                _this2.unobserveArray(value, obj.__rv, keypath);\n\n                value = newValue;\n                var data = _this2.weakmap[obj.__rv];\n\n                if (data) {\n                  var _callbacks = data.callbacks[keypath];\n\n                  if (_callbacks) {\n                    _callbacks.forEach(function (cb) {\n                      cb.sync();\n                    });\n                  }\n\n                  _this2.observeArray(newValue, obj.__rv, keypath);\n                }\n              }\n            }\n          });\n        }\n      }\n\n      if (callbacks[keypath].indexOf(callback) === -1) {\n        callbacks[keypath].push(callback);\n      }\n\n      this.observeArray(obj[keypath], obj.__rv, keypath);\n    },\n    unobserve: function unobserve(obj, keypath, callback) {\n      var data = this.weakmap[obj.__rv];\n\n      if (data) {\n        var callbacks = data.callbacks[keypath];\n\n        if (callbacks) {\n          var idx = callbacks.indexOf(callback);\n\n          if (idx > -1) {\n            callbacks.splice(idx, 1);\n\n            if (!callbacks.length) {\n              delete data.callbacks[keypath];\n              this.unobserveArray(obj[keypath], obj.__rv, keypath);\n            }\n          }\n\n          this.cleanupWeakReference(data, obj.__rv);\n        }\n      }\n    },\n    get: function get(obj, keypath) {\n      return obj[keypath];\n    },\n    set: function set(obj, keypath, value) {\n      obj[keypath] = value;\n    }\n  };\n\n  var getString = function getString(value) {\n    return value != null ? value.toString() : undefined;\n  };\n\n  var times = function times(n, cb) {\n    for (var i = 0; i < n; i++) {\n      cb();\n    }\n  };\n\n  function createView(binding, data, anchorEl) {\n    var template = binding.el.cloneNode(true);\n    var view = new View(template, data, binding.view.options);\n    view.bind();\n    binding.marker.parentNode.insertBefore(template, anchorEl);\n    return view;\n  }\n\n  var binders = {\n    // Binds an event handler on the element.\n    'on-*': {\n      function: true,\n      priority: 1000,\n      unbind: function unbind(el) {\n        if (this.handler) {\n          el.removeEventListener(this.arg, this.handler);\n        }\n      },\n      routine: function routine(el, value) {\n        if (this.handler) {\n          el.removeEventListener(this.arg, this.handler);\n        }\n\n        this.handler = this.eventHandler(value);\n        el.addEventListener(this.arg, this.handler);\n      }\n    },\n    // Appends bound instances of the element in place for each item in the array.\n    'each-*': {\n      block: true,\n      priority: 4000,\n      bind: function bind(el) {\n        if (!this.marker) {\n          this.marker = document.createComment(\" tinybind: \" + this.type + \" \");\n          this.iterated = [];\n          el.parentNode.insertBefore(this.marker, el);\n          el.parentNode.removeChild(el);\n        } else {\n          this.iterated.forEach(function (view) {\n            view.bind();\n          });\n        }\n      },\n      unbind: function unbind(el) {\n        if (this.iterated) {\n          this.iterated.forEach(function (view) {\n            view.unbind();\n          });\n        }\n      },\n      routine: function routine(el, collection) {\n        var _this = this;\n\n        var modelName = this.arg;\n        collection = collection || [];\n        var indexProp = el.getAttribute('index-property') || '$index';\n        collection.forEach(function (model, index) {\n          var data = {\n            $parent: _this.view.models\n          };\n          data[indexProp] = index;\n          data[modelName] = model;\n          var view = _this.iterated[index];\n\n          if (!view) {\n            var previous = _this.marker;\n\n            if (_this.iterated.length) {\n              previous = _this.iterated[_this.iterated.length - 1].els[0];\n            }\n\n            view = createView(_this, data, previous.nextSibling);\n\n            _this.iterated.push(view);\n          } else {\n            if (view.models[modelName] !== model) {\n              // search for a view that matches the model\n              var matchIndex, nextView;\n\n              for (var nextIndex = index + 1; nextIndex < _this.iterated.length; nextIndex++) {\n                nextView = _this.iterated[nextIndex];\n\n                if (nextView.models[modelName] === model) {\n                  matchIndex = nextIndex;\n                  break;\n                }\n              }\n\n              if (matchIndex !== undefined) {\n                // model is in other position\n                // todo: consider avoiding the splice here by setting a flag\n                // profile performance before implementing such change\n                _this.iterated.splice(matchIndex, 1);\n\n                _this.marker.parentNode.insertBefore(nextView.els[0], view.els[0]);\n\n                nextView.models[indexProp] = index;\n              } else {\n                //new model\n                nextView = createView(_this, data, view.els[0]);\n              }\n\n              _this.iterated.splice(index, 0, nextView);\n            } else {\n              view.models[indexProp] = index;\n            }\n          }\n        });\n\n        if (this.iterated.length > collection.length) {\n          times(this.iterated.length - collection.length, function () {\n            var view = _this.iterated.pop();\n\n            view.unbind();\n\n            _this.marker.parentNode.removeChild(view.els[0]);\n          });\n        }\n\n        if (el.nodeName === 'OPTION') {\n          this.view.bindings.forEach(function (binding) {\n            if (binding.el === _this.marker.parentNode && binding.type === 'value') {\n              binding.sync();\n            }\n          });\n        }\n      },\n      update: function update(models) {\n        var _this2 = this;\n\n        var data = {}; //todo: add test and fix if necessary\n\n        Object.keys(models).forEach(function (key) {\n          if (key !== _this2.arg) {\n            data[key] = models[key];\n          }\n        });\n        this.iterated.forEach(function (view) {\n          view.update(data);\n        });\n      }\n    },\n    // Adds or removes the class from the element when value is true or false.\n    'class-*': function _class(el, value) {\n      var elClass = \" \" + el.className + \" \";\n\n      if (!value === elClass.indexOf(\" \" + this.arg + \" \") > -1) {\n        if (value) {\n          el.className = el.className + \" \" + this.arg;\n        } else {\n          el.className = elClass.replace(\" \" + this.arg + \" \", ' ').trim();\n        }\n      }\n    },\n    // Sets the element's text value.\n    text: function text(el, value) {\n      el.textContent = value != null ? value : '';\n    },\n    // Sets the element's HTML content.\n    html: function html(el, value) {\n      el.innerHTML = value != null ? value : '';\n    },\n    // Shows the element when value is true.\n    show: function show(el, value) {\n      el.style.display = value ? '' : 'none';\n    },\n    // Hides the element when value is true (negated version of `show` binder).\n    hide: function hide(el, value) {\n      el.style.display = value ? 'none' : '';\n    },\n    // Enables the element when value is true.\n    enabled: function enabled(el, value) {\n      el.disabled = !value;\n    },\n    // Disables the element when value is true (negated version of `enabled` binder).\n    disabled: function disabled(el, value) {\n      el.disabled = !!value;\n    },\n    // Checks a checkbox or radio input when the value is true. Also sets the model\n    // property when the input is checked or unchecked (two-way binder).\n    checked: {\n      publishes: true,\n      priority: 2000,\n      bind: function bind(el) {\n        var self = this;\n\n        if (!this.callback) {\n          this.callback = function () {\n            self.publish();\n          };\n        }\n\n        el.addEventListener('change', this.callback);\n      },\n      unbind: function unbind(el) {\n        el.removeEventListener('change', this.callback);\n      },\n      routine: function routine(el, value) {\n        if (el.type === 'radio') {\n          el.checked = getString(el.value) === getString(value);\n        } else {\n          el.checked = !!value;\n        }\n      }\n    },\n    // Sets the element's value. Also sets the model property when the input changes\n    // (two-way binder).\n    value: {\n      publishes: true,\n      priority: 3000,\n      bind: function bind(el) {\n        this.isRadio = el.tagName === 'INPUT' && el.type === 'radio';\n\n        if (!this.isRadio) {\n          this.event = el.getAttribute('event-name') || (el.tagName === 'SELECT' ? 'change' : 'input');\n          var self = this;\n\n          if (!this.callback) {\n            this.callback = function () {\n              self.publish();\n            };\n          }\n\n          el.addEventListener(this.event, this.callback);\n        }\n      },\n      unbind: function unbind(el) {\n        if (!this.isRadio) {\n          el.removeEventListener(this.event, this.callback);\n        }\n      },\n      routine: function routine(el, value) {\n        if (this.isRadio) {\n          el.setAttribute('value', value);\n        } else {\n          if (el.type === 'select-multiple') {\n            if (value instanceof Array) {\n              for (var i = 0; i < el.length; i++) {\n                var option = el[i];\n                option.selected = value.indexOf(option.value) > -1;\n              }\n            }\n          } else if (getString(value) !== getString(el.value)) {\n            el.value = value != null ? value : '';\n          }\n        }\n      }\n    },\n    // Inserts and binds the element and it's child nodes into the DOM when true.\n    if: {\n      block: true,\n      priority: 4000,\n      bind: function bind(el) {\n        if (!this.marker) {\n          this.marker = document.createComment(' tinybind: ' + this.type + ' ' + this.keypath + ' ');\n          this.attached = false;\n          el.parentNode.insertBefore(this.marker, el);\n          el.parentNode.removeChild(el);\n        } else if (this.bound === false && this.nested) {\n          this.nested.bind();\n        }\n\n        this.bound = true;\n      },\n      unbind: function unbind() {\n        if (this.nested) {\n          this.nested.unbind();\n          this.bound = false;\n        }\n      },\n      routine: function routine(el, value) {\n        if (!!value !== this.attached) {\n          if (value) {\n            if (!this.nested) {\n              this.nested = new View(el, this.view.models, this.view.options);\n              this.nested.bind();\n            }\n\n            this.marker.parentNode.insertBefore(el, this.marker.nextSibling);\n            this.attached = true;\n          } else {\n            el.parentNode.removeChild(el);\n            this.attached = false;\n          }\n        }\n      },\n      update: function update(models) {\n        if (this.nested) {\n          this.nested.update(models);\n        }\n      }\n    }\n  };\n\n  var formatters = {\n    watch: function watch(value) {\n      return value;\n    },\n    not: function not(value) {\n      return !value;\n    },\n    negate: function negate(value) {\n      return !value;\n    }\n  };\n\n  function _defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  function _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n  }\n\n  function _inheritsLoose(subClass, superClass) {\n    subClass.prototype = Object.create(superClass.prototype);\n    subClass.prototype.constructor = subClass;\n    subClass.__proto__ = superClass;\n  }\n\n  function _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n      return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n  }\n\n  function _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n      o.__proto__ = p;\n      return o;\n    };\n\n    return _setPrototypeOf(o, p);\n  }\n\n  function isNativeReflectConstruct() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n\n    try {\n      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  function _construct(Parent, args, Class) {\n    if (isNativeReflectConstruct()) {\n      _construct = Reflect.construct;\n    } else {\n      _construct = function _construct(Parent, args, Class) {\n        var a = [null];\n        a.push.apply(a, args);\n        var Constructor = Function.bind.apply(Parent, a);\n        var instance = new Constructor();\n        if (Class) _setPrototypeOf(instance, Class.prototype);\n        return instance;\n      };\n    }\n\n    return _construct.apply(null, arguments);\n  }\n\n  function _isNativeFunction(fn) {\n    return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n  }\n\n  function _wrapNativeSuper(Class) {\n    var _cache = typeof Map === \"function\" ? new Map() : undefined;\n\n    _wrapNativeSuper = function _wrapNativeSuper(Class) {\n      if (Class === null || !_isNativeFunction(Class)) return Class;\n\n      if (typeof Class !== \"function\") {\n        throw new TypeError(\"Super expression must either be null or a function\");\n      }\n\n      if (typeof _cache !== \"undefined\") {\n        if (_cache.has(Class)) return _cache.get(Class);\n\n        _cache.set(Class, Wrapper);\n      }\n\n      function Wrapper() {\n        return _construct(Class, arguments, _getPrototypeOf(this).constructor);\n      }\n\n      Wrapper.prototype = Object.create(Class.prototype, {\n        constructor: {\n          value: Wrapper,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      });\n      return _setPrototypeOf(Wrapper, Class);\n    };\n\n    return _wrapNativeSuper(Class);\n  }\n\n  var Component =\n  /*#__PURE__*/\n  function (_HTMLElement) {\n    _inheritsLoose(Component, _HTMLElement);\n\n    function Component() {\n      return _HTMLElement.apply(this, arguments) || this;\n    }\n\n    var _proto = Component.prototype;\n\n    _proto.connectedCallback = function connectedCallback() {\n      var nodes = this.constructor.__templateEl.content.cloneNode(true);\n\n      this.__tinybindView = tinybind.bind(nodes, this);\n\n      while (this.firstChild) {\n        this.removeChild(this.firstChild);\n      }\n\n      this.appendChild(nodes);\n    };\n\n    _proto.disconnectedCallback = function disconnectedCallback() {\n      this.__tinybindView.unbind();\n    };\n\n    _proto.attributeChangedCallback = function attributeChangedCallback(name, old, value) {\n      if (old !== value) {\n        var propName = this.constructor.__propAttributeMap[name];\n        this[propName] = value;\n      }\n    };\n\n    _createClass(Component, null, [{\n      key: \"observedAttributes\",\n      get: function get() {\n        var template = this.template;\n\n        if (!template) {\n          throw new Error(\"No template declared for \" + this.name);\n        }\n\n        this.__templateEl = document.createElement('template');\n        this.__templateEl.innerHTML = template;\n        var propAttributeMap = this.__propAttributeMap = {};\n        var attributes = [];\n        var properties = this.properties;\n\n        if (properties) {\n          Object.keys(properties).forEach(function (propName) {\n            var propConfig = properties[propName];\n            var attrName = typeof propConfig === 'string' ? propConfig : propName;\n            propAttributeMap[attrName] = propName;\n            attributes.push(attrName);\n          });\n        }\n\n        return attributes;\n      }\n    }]);\n\n    return Component;\n  }(_wrapNativeSuper(HTMLElement));\n\n  tinybind.binders = binders;\n  tinybind.formatters = formatters;\n  tinybind.adapters['.'] = adapter;\n  tinybind.Component = Component; // Binds some data to a template / element. Returns a tinybind.View instance.\n\n  tinybind.bind = function (el, models, options) {\n    var viewOptions = {};\n    models = models || {};\n    options = options || {};\n    EXTENSIONS.forEach(function (extensionType) {\n      viewOptions[extensionType] = Object.create(null);\n\n      if (options[extensionType]) {\n        Object.keys(options[extensionType]).forEach(function (key) {\n          viewOptions[extensionType][key] = options[extensionType][key];\n        });\n      }\n\n      Object.keys(tinybind[extensionType]).forEach(function (key) {\n        if (!viewOptions[extensionType][key]) {\n          viewOptions[extensionType][key] = tinybind[extensionType][key];\n        }\n      });\n    });\n    OPTIONS.forEach(function (option) {\n      var value = options[option];\n      viewOptions[option] = value != null ? value : tinybind[option];\n    });\n    viewOptions.starBinders = Object.keys(viewOptions.binders).filter(function (key) {\n      return key.indexOf('*') > 0;\n    });\n    Observer.updateOptions(viewOptions);\n    var view = new View(el, models, viewOptions);\n    view.bind();\n    return view;\n  };\n\n  return tinybind;\n\n}));\n//# sourceMappingURL=tinybind.js.map\n\n\n//# sourceURL=webpack://resources/./node_modules/tinybind/dist/tinybind.js?");

/***/ }),

/***/ "./src/entry.js":
/*!**********************!*\
  !*** ./src/entry.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _js_tinybind_config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./js/tinybind.config */ \"./src/js/tinybind.config.js\");\n/* harmony import */ var _js_tinybind_config__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_js_tinybind_config__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _js_tinybind_components__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./js/tinybind.components */ \"./src/js/tinybind.components.js\");\n/* harmony import */ var _js_tinybind_formatters__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./js/tinybind.formatters */ \"./src/js/tinybind.formatters.js\");\n__webpack_require__( /*! ../node_modules/tinybind/dist/tinybind */ \"./node_modules/tinybind/dist/tinybind.js\");\n\n\n\n\n\n\n//# sourceURL=webpack://resources/./src/entry.js?");

/***/ }),

/***/ "./src/js/components/autocomplete.js":
/*!*******************************************!*\
  !*** ./src/js/components/autocomplete.js ***!
  \*******************************************/
/***/ (function() {

eval("tinybind.binders.autocomplete = {\n  bind: function (el, values) {\n\n  },\n\n  unbind: function (el) {\n    this.autocompleteInstance.destroy();\n  },\n\n  routine: function (el, values) {\n\n    if (this.autocompleteInstance) { this.autocompleteInstance.destroy() };\n\n    this.autocompleteInstance = FLUIGC.autocomplete(el, {\n      highlight: true,\n      minLength: 0,\n      maxTags: 1,\n      hint: true,\n      searchTimeout: 100,\n      type: $(el).attr('ac-type') || 'tagAutocomplete',\n      tagClass: $(el).attr('ac-tag-class') || 'tag-info',\n      displayKey: $(el).attr('ac-display-key'),\n      templates: {\n        tag: $(el).attr('ac-tag-template'),\n        suggestion: $(el).attr('ac-tag-template')\n      },\n      source: substringMatcher(values, $(el).attr('ac-display-key')),\n    }, function (err, data) {\n      if (err) {\n        try {\n          errMessage = JSON.parse(err.responseText.message);\n          errMessage = errMessage.message ? err.responseText.message : err.responseText;\n        } catch (e) {\n          errMessage = 'Não foi possível listar os dados';\n        }\n        FLUIGC.toast({\n          message: errMessage,\n          type: 'danger'\n        });\n      }\n    });\n\n    this.autocompleteInstance.on('fluig.autocomplete.itemAdded', this.publish);\n  },\n\n\n}\n\nitemAdded = (ev, el) => {\n  console.log(ev, el);\n  this.dispatchEvent(new CustomEvent('itemchanged', { 'item': ev.item }));\n\n  // new CustomEvent('itemchanged', { 'item': el.item })\n}\nsubstringMatcher = (strs, name) => {\n\n  return function findMatches(q, cb) {\n    var matches, substrRegex;\n\n    matches = [];\n\n    substrRegex = new RegExp(q, 'i');\n\n    $.each(strs, function (i, str) {\n      if (substrRegex.test(str[name])) {\n        matches.push(str);\n      }\n    });\n    cb(matches);\n  };\n}\n\n\n//# sourceURL=webpack://resources/./src/js/components/autocomplete.js?");

/***/ }),

/***/ "./src/js/formatters/and.js":
/*!**********************************!*\
  !*** ./src/js/formatters/and.js ***!
  \**********************************/
/***/ (() => {

eval("tinybind.formatters.and = function (comparee, comparator) {\n  return comparee && comparator;\n};\n\n//# sourceURL=webpack://resources/./src/js/formatters/and.js?");

/***/ }),

/***/ "./src/js/tinybind.components.js":
/*!***************************************!*\
  !*** ./src/js/tinybind.components.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _components_autocomplete__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./components/autocomplete */ \"./src/js/components/autocomplete.js\");\n/* harmony import */ var _components_autocomplete__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_components_autocomplete__WEBPACK_IMPORTED_MODULE_0__);\n\n\n//# sourceURL=webpack://resources/./src/js/tinybind.components.js?");

/***/ }),

/***/ "./src/js/tinybind.config.js":
/*!***********************************!*\
  !*** ./src/js/tinybind.config.js ***!
  \***********************************/
/***/ (() => {

eval("tinybind.configure({\n\n  // Attribute prefix in templates\n  prefix: 'leme',\n\n  // Preload templates with initial data on bind\n  preloadData: true,\n\n  // Root sightglass interface for keypaths\n  rootInterface: '.',\n\n  // Template delimiters for text bindings\n  templateDelimiters: ['{', '}'],\n\n  // Augment the event handler of the on-* binder\n  handler: function(target, event, binding) {\n    this.call(target, event, binding.view.models)\n  }\n\n})\n\n//# sourceURL=webpack://resources/./src/js/tinybind.config.js?");

/***/ }),

/***/ "./src/js/tinybind.formatters.js":
/*!***************************************!*\
  !*** ./src/js/tinybind.formatters.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _formatters_and__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./formatters/and */ \"./src/js/formatters/and.js\");\n/* harmony import */ var _formatters_and__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_formatters_and__WEBPACK_IMPORTED_MODULE_0__);\n\n\n//# sourceURL=webpack://resources/./src/js/tinybind.formatters.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/entry.js");
/******/ 	
/******/ })()
;